Программая документация на игру TYPE & SLAYER

1. ВВЕДЕНИЕ
-----------
Данный документ представляет собой техническое описание программного
обеспечения «Type & Slayer» — компьютерной игры в жанре «рогалик»
(Roguelike) с механикой набора текста (печати).

Назначение программы:
Программа предназначена для развлечения и тренировки навыков быстрой
и безошибочной печати. Игровой процесс сочетает в себе динамику защиты
базы (игрока) от наступающих врагов и необходимость ввода слов, которые
несут эти враги, для их уничтожения.

Область применения:
Персональные компьютеры под управлением операционных систем,
поддерживающих библиотеку Pygame (Windows, macOS, Linux).

Краткая характеристика возможностей:
* Управление персонажем игрока путем уничтожения врагов через набор слов.
* Прогрессия уровня игрока: увеличение максимального здоровья и усложнение
  врагов.
* Система опыта и повышения уровня.
* Генерация врагов со словами, сложность которых зависит от текущего
  уровня игрока.
* Визуальная виртуальная клавиатура, отображающая нажатия.
* Подсветка врага, слово которого совпадает с текущим вводом.


2. ЧАСТНОЕ ТЕХНИЧЕСКОЕ ЗАДАНИЕ НА ПОДСИСТЕМУ УПРАВЛЕНИЯ ПЕЧАТЬЮ
----------------------------------------------------------------
1. Цель разработки
Разработать подсистему, которая будет распознавать вводимые пользователем
с физической клавиатуры символы, сопоставлять их со словами-целями на
игровых объектах (врагах) и инициировать их уничтожение при полном
совпадении.

2. Функциональные требования
* Подсистема должна захватывать события нажатия клавиш из основного цикла
  игры.
* Подсистема должна формировать строку (typed_word) из введенных символов.
* Подсистема должна обрабатывать специальные клавиши:
  * Backspace: удаление последнего символа из строки.
  * Enter: передача сформированной строки на проверку.
  * Escape: полная очистка строки ввода.
* Подсистема должна игнорировать неалфавитные символы.
* Подсистема должна визуализировать процесс ввода, отображая текущую строку
  на экране.

3. Требования к интерфейсу
* Визуальная клавиатура должна отображать состояние нажатия клавиш.
* Враг, чье слово совпадает с текущей введенной строкой, должен
  подсвечиваться (например, контуром другого цвета).
* Поле ввода должно отображать текущий ввод с мигающим курсором.

4. Требования к логике работы
* При нажатии Enter, подсистема должна сравнить typed_word со словами всех
  активных врагов.
* При совпадении враг должен быть удален из списка объектов, игроку должны
  начисляться очки и опыт.
* Строка ввода должна очищаться после успешного уничтожения врага или при
  нажатии Escape.
* Подсистема не должна учитывать регистр вводимых символов (все символы
  приводятся к нижнему регистру).


3. СТРУКТУРНАЯ СХЕМА ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ
-----------------------------------------------
3.1. Общая структурная схема программ

Программа построена по принципу объектно-ориентированной иерархии.
Точкой входа является модуль main.py, который инициализирует Pygame
и создает экземпляр класса Game, управляющий всем жизненным циклом игры.

Схема взаимодействия модулей:

main.py (Точка входа)
    │
    └── game.py (Класс Game - основной управляющий модуль)
         ├── player.py (Класс Player - состояние и отрисовка игрока)
         ├── enemy.py (Класс Enemy - состояние и отрисовка врагов)
         ├── keyboard.py (Класс VirtualKeyboard - визуализация клавиатуры)
         └── utils/
              └── word_generator.py (Класс WordGenerator - генерация слов)

3.2. Порядок взаимодействия частей подсистемы

1. Инициализация: main.py создает объект Game, который, в свою очередь,
   создает объекты Player, VirtualKeyboard и WordGenerator.
2. Ввод: Модуль game.py получает события клавиш из основного цикла main.py
   и передает их в метод handle_event.
3. Обработка ввода:
   * Game.handle_event обрабатывает нажатия, формируя строку typed_word.
   * Для визуальной обратной связи вызывается метод keyboard.press_key().
   * При нажатии Enter вызывается метод check_word().
4. Игровая логика:
   * Game.check_word() итерируется по списку enemies (объекты Enemy).
   * При совпадении enemy.word и typed_word, враг удаляется, начисляются
     очки и опыт (player.gain_exp()).
5. Обновление состояний:
   * Game.update() вызывает обновление позиций врагов (enemy.update()),
     проверяет коллизии (достижение края), уровень игрока и управляет
     спавном новых врагов через WordGenerator.
6. Отрисовка:
   * Game.draw() последовательно вызывает методы draw() у player,
     всех enemies и keyboard, а также отрисовывает интерфейс и поле ввода.


4. ПЕРЕЧЕНЬ И НУМЕРАЦИЯ СОБЫТИЙ
---------------------------------
Взаимодействие с программой строится на обработке событий. События для
автомата состояний игры (в данном случае, для конечного автомата Game):

| № события | Название события  | Источник     | Описание                                      |
|-----------|-------------------|--------------|-----------------------------------------------|
| E1        | ev_quit           | Пользователь | Закрытие окна программы (событие pygame.QUIT)|
| E2        | ev_key_down       | Пользователь | Нажатие любой клавиши на физической клавиатуре|
| E3        | ev_key_enter      | Пользователь | Нажатие клавиши Enter                         |
| E4        | ev_key_backspace  | Пользователь | Нажатие клавиши Backspace                      |
| E5        | ev_key_escape     | Пользователь | Нажатие клавиши Escape                         |
| E6        | ev_player_death   | Внутреннее   | Здоровье игрока (player.health) становится ≤ 0|
| E7        | ev_enemy_reached  | Внутреннее   | Позиция врага достигает левого края (x < 50)  |
| E8        | ev_word_match     | Внутреннее   | Успешное совпадение строки ввода со словом    |
| E9        | ev_exp_full       | Внутреннее   | Опыт игрока достиг порога exp_to_next         |
| E10       | ev_timer_spawn    | Внутреннее   | Срабатывание таймера спавна врагов            |
| E11       | ev_restart        | Пользователь | Нажатие R на экране "Игра окончена" или "Победа"|


5. ПЕРЕЧЕНЬ И НУМЕРАЦИЯ ВХОДНЫХ ПЕРЕМЕННЫХ
-------------------------------------------
Переменные, которые влияют на логику работы программы и поступают извне
(от пользователя или из конфигурации).

| №  | Имя переменной | Тип данных         | Диапазон / Допустимые значения | Описание                          |
|----|----------------|--------------------|---------------------------------|-----------------------------------|
| V1 | key_unicode    | str                | Любой печатаемый символ         | Символ нажатой клавиши           |
| V2 | mouse_pos      | tuple(int, int)    | В пределах окна (0..1024, 0..768)| Координаты курсора мыши         |
| V3 | window_size    | tuple(int, int)    | (1024, 768)                     | Размер игрового окна             |


6. ПЕРЕЧЕНЬ И НУМЕРАЦИЯ ВЫХОДНЫХ ВОЗДЕЙСТВИЙ
---------------------------------------------
Действия, которые программа производит над интерфейсом и внутренним
состоянием в ответ на события.

| №  | Название воздействия | Получатель        | Описание                                     |
|----|----------------------|-------------------|----------------------------------------------|
| A1 | draw_scene           | Экран             | Отрисовка всех игровых объектов на экране    |
| A2 | update_display       | Экран             | Обновление содержимого окна                  |
| A3 | play_sound           | Звуковая подсистема| Воспроизведение звукового эффекта           |
| A4 | spawn_new_enemy      | Список enemies    | Создание нового экземпляра класса Enemy      |
| A5 | remove_enemy         | Список enemies    | Удаление конкретного врага из списка         |
| A6 | damage_player        | Объект player     | Уменьшение здоровья игрока                   |
| A7 | add_exp              | Объект player     | Увеличение опыта игрока                      |
| A8 | level_up_player      | Объект player     | Повышение уровня игрока                      |
| A9 | clear_input          | Поле typed_word   | Очистка строки текущего ввода                |
| A10| append_char          | Поле typed_word   | Добавление символа к строке текущего ввода   |
| A11| pop_char             | Поле typed_word   | Удаление последнего символа из строки ввода  |


7. ПОЯСНЕНИЯ К ИСПОЛЬЗУЕМОЙ НОТАЦИИ
------------------------------------
7.1. Нотация, используемая в графах переходов

Для описания логики работы основных классов (автоматов) используется
нотация, основанная на диаграммах состояний.

* Состояние (State): Прямоугольник с закругленными углами, обозначающий
  режим работы объекта. Пример: ИГРА, ПАУЗА.
* Событие (Event): Триггер, который вызывает переход из одного состояния
  в другое. Обозначается текстом над стрелкой перехода. Пример: ev_player_death.
* Переход (Transition): Стрелка, соединяющая два состояния. Показывает,
  в какое состояние перейдет автомат при наступлении события.
* Действие (Action): Может быть указано на переходе в скобках {} и
  описывает выходное воздействие, которое произойдет во время перехода.
  Пример: {A5, A7} (удалить врага и начислить опыт).

7.2. Схема универсального алгоритма реализации автоматов

Реализация конечного автомата в классе Game происходит по следующей схеме
в методе update(dt) и handle_event(event):

1. Определение текущего состояния: Проверка флагов self.game_over и
   self.victory.
2. Обработка внешних событий: В handle_event(event) на основе типа события
   и текущего состояния вызываются соответствующие методы (например,
   check_word()).
3. Обработка внутренних событий: В update(dt) проверяются условия для
   генерации внутренних событий:
   * Проверка здоровья игрока (if self.player.health <= 0) -> ev_player_death.
   * Проверка достижения врагами края -> ev_enemy_reached.
   * Проверка накопления опыта -> ev_exp_full.
   * Проверка таймера спавна -> ev_timer_spawn.
4. Выполнение действий и смена состояний: При срабатывании события
   выполняются соответствующие выходные воздействия (A1..A11) и, при
   необходимости, изменяются флаги состояния.

7.3. Шаблон Си-функции, реализующей автомат

Несмотря на то, что проект написан на Python, логику автомата можно
представить в виде псевдокода, аналогичного шаблону на Си.

// Псевдокод, описывающий логику автомата игры (упрощенно)
typedef enum { STATE_PLAYING, STATE_GAME_OVER, STATE_VICTORY } GameState;

void game_handle_event(GameState *state, Event event, GameData *data) {
    switch (*state) {
        case STATE_PLAYING:
            if (event.type == EV_KEY_DOWN) {
                handle_typing(event.key, data); // A9, A10, A11
                if (event.key == KEY_ENTER) {
                    check_word_match(data); // A5, A7
                }
            }
            // Проверка условий для смены состояния
            if (data->player.health <= 0) { // ev_player_death
                *state = STATE_GAME_OVER;
                // Можно добавить действие A1 (перерисовать экран с затемнением)
            }
            break;

        case STATE_GAME_OVER:
        case STATE_VICTORY:
            if (event.type == EV_KEY_DOWN && event.key == KEY_R) { // ev_restart
                reset_game(data); // Сброс всех параметров
                *state = STATE_PLAYING;
            }
            break;
    }
}

void game_update(GameState *state, float dt, GameData *data) {
    if (*state != STATE_PLAYING) return;

    // Логика обновления в состоянии игры
    update_enemies(dt, data); // Движение врагов
    check_enemies_reached_base(data); // Проверка ev_enemy_reached, вызов damage_player (A6)
    update_spawn_timer(dt, data); // Проверка ev_timer_spawn, вызов spawn_new_enemy (A4)
    check_level_up(data); // Проверка ev_exp_full, вызов level_up_player (A8)
}